jnanomsg documentation
======================
Andrey Antukh, <niwi@niwi.be>
1.0, 2014-01-02

:toc:
:numbered:


Introduction
------------

link:http://nanomsg.org[nanomsg] is a socket library that provides common communication patterns.

Install
-------

This section covers a installation of _jnanomsg_.

Leiningen
~~~~~~~~~

The simplest way to use _jnanomsg_ on clojure project, is including it on dependency
vector of your *_project.clj_* file:

._`:requirements` vectory entry_
[source,clojure]
----
[jnanomsg "0.1.0"]
----

Maven
~~~~~

Also, you can use it on your java projects with maven. As first step add a clojars repository:

[source,xml]
----
<repository>
    <id>clojars.org</id>
    <url>http://clojars.org/repo</url>
</repository>
----

Following of jnanomsg package dependecy:

[source,xml]
----
<dependency>
    <groupId>jnanomsg</groupId>
    <artifactId>jnanomsg</artifactId>
    <version>0.1.0</version>
</dependency>
----

Supported features
------------------

Transports
~~~~~~~~~~

jnanomsg supports all transports supported by their backend (nanomsg): ipc, inproc, tcp

Protocols
~~~~~~~~~

jnanomsg intends support all protocols supported by a native nanomsg library:

* pub/sub protocol
* req/rep protocol
* bus protocol
* pair protocol


[NOTE]
This documentation not intends explain how works each protocol. It intends only explain
a public api of idiomatic library for java and clojure.


User guide
----------

All public api for work with nanomsg library is exposed under `nanomsg` clojure namespace. However,
with java api, each socket type has it own package and it own class.

Example requiring namespace on clojure file:

._yours/samplens.clj_
[source,clojure]
----
(ns yours.samplens
  (:require [nanomsg :as nn]))
----


Pub/Sub Sockets
~~~~~~~~~~~~~~~

This protocol has two socket types:

- _publisher_ - This socket is used to distribute messages to multiple destinations. Receive operation is not defined.
- _subscriber_ - Receives messages from the publisher. Only messages that the socket is subscribed to are received. When the socket is created there are no subscriptions and thus no messages will be received. Send operation is not defined on this socket.


Clojure
^^^^^^^

On clojure, a socket types are represented by keywords and this socket pair is represented by
`:pub` and `:sub` keyworks (publisher and subscriber sockets respectivelly).

Example:

._publisher.clj_
[source,clojure]
----
(let [sock (nn/socket :pub)]
  (nn/bind sock "ipc:///tmp/sock")
  (dotimes [i 5]
    (nn/send sock "test msg"))
  (nn/close sock))
----

._subscriber.clj_
[source,clojure]
----
(let [sock (nn/socket :sub)]
  (nn/connect sock "ipc:///tmp/sock")
  (nn/subscribe sock "test")
  (dotimes [i 5]
    (println (nn/recv sock)))
  (nn/close sock))
----

Java
^^^^

On java, publisher and subscriber has own classes that are available on `nanomsg.pubsub` package:

._Publisher.java_
[source,java]
----
import nanomsg.pubsub.PubSocket;

public class Publisher {
    public static void main(String[] args) {
        PubSocket sock = new PubSocket();
        sock.bind("ipc:///tmp/sock");

        for(int i=0; i<5; i++) {
            sock.sendString("test msg");
        }

        sock.close()
    }
}
----

._Subscriber.java_
[source,java]
----
import nanomsg.pubsub.SubSocket;

public class Subscriber {
    public static void main(String[] args) {
        SubSocket sock = new SubSocket();
        sock.connect("ipc:///tmp/sock");
        sock.subscribe("test");

        for(int i=0; i<5; i++) {
            System.out.println(sock.recvString());
        }

        sock.close()
    }
}
----


Req/Rep Sockets
~~~~~~~~~~~~~~~

This protocol is used to distribute the workload among multiple stateless workers, and it's represented
by two socket types:

- _req_ - Used to implement the client application that sends requests and receives replies.
- _rep_ - Used to implement the stateless worker that receives requests and sends replies.

NOTE: Both sockets implements read and write methods.

Clojure
^^^^^^^

"Hello World" echo server using clojure:

._rep.clj (server)_
[source,clojure]
----
(let [sock (nn/socket :rep)]
  (nn/bind sock "tcp://*:6789")
  (loop []
    (nn/send sock (nn/recv sock))
    (recur)))
----

._req.clj (client)_
[source,clojure]
----
(let [sock (nn/socket :req)]
  (nn/bind sock "tcp://localhost:6789")
  (dotimes [i 5]
    (nn/send sock (str "msg:" 1))
    (println "Received:" (nn/recv sock))))
----

Java
^^^^

Same examples as on clojure section, but using java:

._EchoServer.java_
[source,java]
----
import nanomsg.reqrep.RepSocket;

public class EchoServer {
    public static void main(String[] args) {
        RepSocket sock = new RepSocket();
        sock.bind("tcp://*:6789");

        while (true) {
            byte[] receivedData = sock.recvBytes();
            sock.sendBytes(receivedData);
        }

        sock.close()
    }
}
----

._EchoClient.java_
[source,java]
----
import nanomsg.reqrep.ReqSocket;

public class EchoClient {
    public static void main(String[] args) {
        ReqSocket sock = new ReqSocket();
        sock.connect("tcp://localhost:6789");

        for (int i=0; i<5; i++) {
            sock.sendString("Hello!" + 1);
            System.out.println("Received:" + sock.recvString());
        }

        sock.close()
    }
}
----


License
-------

----
Copyright 2013 Andrey Antukh <niwi@niwi.be>

Licensed under the Apache License, Version 2.0 (the "License")
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
----
