jnanomsg documentation
======================
Andrey Antukh, <niwi@niwi.be>
1.0, 2014-01-02

:toc:
:numbered:


Introduction
------------

link:http://nanomsg.org[nanomsg] is a socket library that provides common communication patterns.

Install
-------

This section covers a installation of _jnanomsg_.

Leiningen
~~~~~~~~~

The simplest way to use _jnanomsg_ on clojure project, is including it on dependency
vector of your *_project.clj_* file:

.Part of _project.clj_
[source,clojure]
----
[jnanomsg "0.1.0"]
----

Maven
-----

Also, you can use it on your java projects with maven. As first step add a clojars repository:

[source,xml]
----
<repository>
    <id>clojars.org</id>
    <url>http://clojars.org/repo</url>
</repository>
----

Following of jnanomsg package dependecy:

[source,xml]
----
<dependency>
    <groupId>jnanomsg</groupId>
    <artifactId>jnanomsg</artifactId>
    <version>0.1.0</version>
</dependency>
----

Supported features
------------------

Transports
~~~~~~~~~~

jnanomsg supports all transports supported by their backend (nanomsg): ipc, inproc, tcp

Protocols
~~~~~~~~~

jnanomsg intends to support all available protocols from nanomsg but at the moment only supports a few ones:

* `:pub` - this socket type is used to distribute messages to multiple destinations. Receive operation is not defined.
* `:sub` - this socket typee is used to receives messages from the publisher. Send operation is not defined on this socket.
* `:req` - this socket type is used to implement the client application that sends requests and receives replies.
* `:rep` - this socket type is used to implement the stateless worker that receives requests and sends replies.
* `:bus` - this socket type is used to send messages to all nodes in the topology.
* `:pair` - this socket type is uded to implement communication with exactly one peer.

[NOTE]
You can see more description of each protocol of main page of this documentation or going
directly to nanomsg page.

User guide
----------

Import namespace/package
~~~~~~~~~~~~~~~~~~~~~~~~

Using Clojure
^^^^^^^^^^^^^

All available functions for work with nanomsag with clojure are available on `nanomsg` namespace.

This is a recommended way to import nanomsg ns on repl:

[source,clojure]
----
(require [nanomsg :as nn])
----

Or on ns macro:

._yours/samplens.clj_
[source,clojure]
----
(ns yours.samplens
  (:require [nanomsg :as nn]))
----

Using java
^^^^^^^^^^

On java api, each socket type is located on their own package and all import depend of
socket type that are you going to use. For more precise information, see import 
statements on on java examples on the following sections.


Pub/Sub Sockets
~~~~~~~~~~~~~~~

This protocol has two socket types: publisher and subscriber. Publisher socket broadcast messages 
to subscribers clients.

Subscriber sockets always need subscribe to some topic, in other case no messages will be received.

Using Clojure
^^^^^^^^^^^^^

On clojure, a socket types are represented by keywords and this socket pair is represented by
`:pub` and `:sub` keyworks (publisher and subscriber sockets respectivelly).

Example:


._publisher.clj_
[source,clojure]
----
(let [sock (nn/socket :pub)]
  (nn/bind sock "ipc:///tmp/sock")
  (dotimes [i 5]
    (nn/send sock "test msg"))
  (nn/close sock))
----

._subscriber.clj_
[source,clojure]
----
(let [sock (nn/socket :sub)]
  (nn/connect sock "ipc:///tmp/sock")
  (nn/subscribe sock "test")
  (dotimes [i 5]
    (println (nn/recv sock)))
  (nn/close sock))
----

Using java
^^^^^^^^^^

On java, publisher and subscriber has own classes thar represent distinct socket 
type (all located on `nanomsg.pubsub` package).

Examples:

._Publisher.java_
[source,java]
----
import nanomsg.pubsub.PubSocket;

public class Publisher {
    public static void main(String[] args) {
        PubSocket sock = new PubSocket();
        sock.bind("ipc:///tmp/sock");

        for(int i=0; i<5; i++) {
            sock.sendString("test msg");
        }

        sock.close()
    }
}
----

._Subscriber.java_
[source,java]
----
import nanomsg.pubsub.SubSocket;

public class Subscriber {
    public static void main(String[] args) {
        SubSocket sock = new SubSocket();
        sock.connect("ipc:///tmp/sock");
        sock.subscribe("test");

        for(int i=0; i<5; i++) {
            System.out.println(sock.recvString());
        }

        sock.close()
    }
}
----


Req/Rep Sockets
~~~~~~~~~~~~~~~

This protocol is used to distribute the workload among multiple stateless workers, and it's represented
by two socket types: req (client) and rep (server).

Both sockets implements read and write methods.

Using clojure
^^^^^^^^^^^^^

This is a simple example implementing a hello world echo server:

._rep.clj (server)_
[source,clojure]
----
(let [sock (nn/socket :rep)]
  (nn/bind sock "tcp://*:6789")
  (loop []
    (nn/send sock (nn/recv sock))
    (recur)))
----

._req.clj (client)_
[source,clojure]
----
(let [sock (nn/socket :req)]
  (nn/bind sock "tcp://localhost:6789")
  (dotimes [i 5]
    (nn/send sock (str "msg:" 1))
    (println "Received:" (nn/recv sock))))
----

Using java
^^^^^^^^^^

._EchoServer.java_
[source,java]
----
import nanomsg.reqrep.RepSocket;

public class EchoServer {
    public static void main(String[] args) {
        RepSocket sock = new RepSocket();
        sock.bind("tcp://*:6789");

        while (true) {
            byte[] receivedData = sock.recvBytes();
            sock.sendBytes(receivedData);
        }

        sock.close()
    }
}
----

._EchoClient.java_
[source,java]
----
import nanomsg.reqrep.ReqSocket;

public class EchoClient {
    public static void main(String[] args) {
        ReqSocket sock = new ReqSocket();
        sock.connect("tcp://localhost:6789");

        for (int i=0; i<5; i++) {
            sock.sendString("Hello!" + 1);
            System.out.println("Received:" + sock.recvString());
        }

        sock.close()
    }
}
----


License
-------

----
Copyright 2013 Andrey Antukh <niwi@niwi.be>

Licensed under the Apache License, Version 2.0 (the "License")
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
----
